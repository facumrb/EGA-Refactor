1. Arquitectura General del Pipeline y Flujo de Datos

[ Usuario ] --> ejecuta --> [ run_demo.py ]
                                    |
                                    | (1. Carga config)
                                    v
                            [ config.yaml ]
                                    |
                                    | (2. Inicializa EGA y Evaluador)
        ____________________________|_____________________________
        |                                                          |
        v                                                          v
[ ega_core.py ] <--------- (4. Bucle Evolutivo) --------> [ evaluator_toy.py ]
(El Optimizador)         (Evalúa cada individuo)         (El Sistema Biológico)
        |                                                          |
        | (3. Propone soluciones)                                  | (5. Devuelve 'fitness')
        |__________________________________________________________|                             
                                    |
                                    | (6. Reporta resultado final)
                                    v
                          [ consola/snapshots ]

Flujo de Datos:
1. run_demo.py es el director de orquesta. Lee los parámetros desde config.yaml.
2. Con esta configuración, crea dos objetos principales: una instancia de EGA (el motor de búsqueda) y una instancia de ToyODEEvaluator (el problema a resolver).
3. El EGA genera una población inicial de "individuos". Cada individuo no es más que un conjunto de parámetros candidatos para el modelo biológico.
4. Aquí comienza el bucle principal: el EGA le pide al evaluator que determine qué tan "bueno" es cada individuo (solución).
5. El evaluator ejecuta una simulación biológica (resuelve las EDOs) con los parámetros del individuo y devuelve un puntaje de fitness (un número que indica qué tan cerca estuvo el resultado del objetivo deseado).
6. El EGA usa estos puntajes para crear una nueva generación de individuos, favoreciendo a los mejores (elitismo, selección) y explorando nuevas posibilidades (cruzamiento, mutación). Este ciclo se repite hasta que se alcanza el número de generaciones definido.

2. Teoría Aplicada
Esta arquitectura implementa directamente el concepto de Problema Inverso que se menciona en el archivo `Teoría.md` .

- El modelo es el sistema de EDOs dentro de evaluator_toy.py .
- Los datos experimentales (o el comportamiento deseado) es el target en config.yaml .
- El problema es encontrar los parámetros ( prod , deg , inter ) que hacen que el modelo replique el target .
- El método de solución es el Algoritmo Genético de ega_core.py , que explora el vasto "paisaje de fitness" de posibles parámetros para encontrar el mínimo global (la mejor solución).

`ega_core.py` : Es pura matemática y computación evolutiva. No "sabe" nada de biología. Su única tarea es optimizar una función objetivo (encontrar el valor más bajo posible).
`evaluator_toy.py` : Es pura biología de sistemas (simplificada). Contiene el conocimiento del dominio: cómo los genes interactúan ( _ode_system ) y qué define una "buena" solución biológica ( evaluate ).
Esta separación permite, por ejemplo, cambiar el modelo biológico por uno completamente diferente (ej. una red neuronal, un modelo metabólico) sin tener que tocar una sola línea de ega_core.py .

3. Puntos Clave de Interpretación
- Abstracción : El EGA trata a cada individuo como una "caja negra". Solo le interesan los parámetros que entran y el fitness que sale. La complejidad biológica está encapsulada en el evaluador.
- Costo Computacional : El cuello de botella de todo el pipeline es casi siempre la función evaluate en el evaluador. Resolver sistemas de EDOs es costoso, y el EGA necesita hacerlo miles de veces. Por eso, la implementación usa pebble para paralelizar este paso.
- Parámetros Críticos : Los parámetros en config.yaml no son triviales. Definen tanto el comportamiento del algoritmo de búsqueda (ej. populationSize , mutation_rate ) como la propia definición del problema biológico (ej. target , t_span ). Un mal ajuste aquí puede llevar a que el algoritmo nunca encuentre una buena solución o tarde demasiado.

Leer todo a continuación antes de empezar:
Tarea: recolectar los estudios que sustentan al proyecto.
        Para completar esta tarea se recomienda:
        1. Leer el código recorriendo las funciones que el sistema recorre al ser ejecutado.
                Nota: Luego del quinto punto (5.) se muestra cómo debe ser recorrido el sistema.
        2. Leer los comentarios de cada función para comprender el funcionamiento de cada parte.
        3. Por cada parte, identificar la teoría que sustenta a la función y los valores del sistema (constante, variables, etc).
                Nota: Los comentarios dan una introducción guía que no es suficiente. Por lo tanto se debe investigar el significado biológico de los valores de atributos, variables, funciones, etc. que se definen en el código para llegar a la exactitud biológica:
                ¿Por qué se tienen ciertos valores? ¿Cómo se relacionan? ¿En qué contexto biológico se determinan? Se recomienda buscar estudios con relación directa a la aplicación de nuestro proyecto.
                En `demo\Estudios` dejo el avance que logré con respecto a la investigación, se puede tomar como base. Se recomienda leer los abstract y conclusion de cada estudio para minimizar el tiempo de análisis.
        4. En base a la información invetigada, seleccionar los estudios que mayor relevancia tienen e identificar sus partes para articularlas y así estructurar la teoría.
                Nota: Los estudios seleccionados sí tienen que ser analizados más allá del abstract y conclusion para verificar que responder correctamente a nuestro proyecto.
        5. Por último, la teoría es una recopilación de estudios que sustenta paso a paso el por qué de nuestro proyecto.

        Atención.. se debe hacer investigación en cómo se define cada constante del código.
        Cómo recorrer el sistema:
        run_demo.py
                + def main(): - Comienzo del sistema.
                        recorrer hasta ...
                + user_config = load_config(args.config)
                + def load_config(path):
                        recorrer hasta ...
                + return config
                + default_config = get_default_config()
                + def get_default_config():
                        recorrer hasta ...
                + "snapshot_dir": "snapshots"
                + validate_config(user_config, default_config)
                + def validate_config(user_config, default_config):
                        recorrer hasta ...
                + warnings.warn(f"Claves desconocidas en config.yaml: {unknown_keys}. Serán ignoradas.") 
                + config = {**default_config, **user_config}
        config.yaml
                recorrer completo para tener una visión general.
                por el momento es necesario conocer los valores y qué son
                pero al momento de ser usados debe investigarse la teoría
        run_demo.py
                + # Parámetros del evaluador
                        recorrer hasta ...
                + evaluator = ToyODEEvaluator(evaluator_config)
        evaluator_toy.py
                + class ToyODEEvaluator:
                        recorrer hasta ...
                + self.bounds = np.array(bounds, dtype=float) if bounds is not None else DEFAULT_BOUNDS
                        (prestar atención a los valores de las constantes y el uso en config.yaml para investigar)
        run_demo.py
                + # Configuración del EGA
                        recorrer hasta ...
                + ega = EGA(ega_config, evaluator)
        ega_core.py
                + class EGA:
                        recorre hasta ...
                + self.population = [Individual(self.bounds, self.strategy) for _ in range(self.pop_size)]
                + class Individual:
                        recorrer hasta ...
                + self.fitness = None
                + self.history = {"min": [], "avg": [], "gen_time": []}
        run_demo.py
                + results = ega.run(snapshot_dir=config["snapshot_dir"], verbose=True)
        ega_core.py
                + run(self, snapshot_dir="snapshots", verbose=True)
                        recorrer hasta
                + self._evaluate_population(self.population)
                + def _evaluate_population(self, population_to_eval=None):
                        recorrer hasta
                + key_for_Dictionary = safe_round_tuple(individual.decode())
                + def decode(self):
                        recorrer hasta
                + return np.clip(self.params, self.bounds[:,0], self.bounds[:,1])
                + key_for_Dictionary = safe_round_tuple(individual.decode())
                + def safe_round_tuple(individual_arr, digits=6):
                        recorrer hasta
                + return tuple([round(float(gen), digits) for gen in individual_arr])
                + if key_for_Dictionary in self.cache:
                        recorrer hasta ...
                + with pebble.ProcessPool(max_workers=self.processes, initializer=init_worker, initargs=(self.seed,)) as pool:
                + def init_worker(seed_base: int):
                        recorrer hasta ...
                + _np.random.seed(s)
                + with pebble.ProcessPool(max_workers=self.processes, initializer=init_worker, initargs=(self.seed,)) as pool:
                        recorrer hasta ...
                + future = pool.map(_evaluator_wrapper, tasks_for_evaluator, timeout=self.timeout)
                + def _evaluator_wrapper(evaluator_and_individual):
                        recorrer hasta ...
                + return evaluator.evaluate(individual)
        evaluator_toy.py
                + def evaluate(self, individual):
                        recorrer hasta ...
                + y_final, solution = self.simulate(individual)
                + def simulate(self, individual):
                        recorrer hasta ...
                + solution = solve_ivp(fun=lambda t, y: self._ode_system(t, y, individual), t_span=(t0, tf), y0=y0, t_eval=t_eval, vectorized=False, rtol=1e-3, atol=1e-6)
                + def _ode_system(self, t, y, individual_params):
                        recorrer hasta ...
                + return dydt
                + # 3. Extraer el estado final del sistema.
                        recorrer hasta ...
                + raise ValueError(f"Simulación fallida para individuo: {error}")
                + if y_final is None:
                        recorrer hasta ...
                + L2_distance = self._calculate_L2_distance(y_final)
                + def _calculate_L2_distance(self, y_final):
                        recorrer hasta
                + return np.linalg.norm(y_final - self.target) # Siempre es positivo
                + complexity_penalty = self._calculate_complexity_penalty(individual)
                + def _calculate_complexity_penalty(self, individual):
                        recorrer hasta ...
                + return self.fitness_penalty_factor * np.sum(np.abs(individual))
                + reached_reward = self._calculate_reached_reward(solution)
                + def _calculate_reached_reward(self, solution):
                        recorrer hasta ...
                + if self._calculate_L2_distance(y) < self._calculate_reward_tolerance():
                + def _calculate_reward_tolerance(self):
                        recorrer hasta
                + return base_tolerance * scale_factor * noise_factor
                + if self._calculate_L2_distance(y) < self._calculate_reward_tolerance():
                        recorrer hasta
                + return 0.0
                + # El fitness total es la suma de sus componentes
                        recorrer hasta
                + return float('inf') # Penalización para fallos en simulación
        ega_core.py
                + iterator = future.result()
                        recorrer hasta ...
                + self.cache[key_for_Dictionary] = individual.fitness
                + self._evaluate_population(self.population)
                        recorrer hasta ...
                + self._record_stats() # Primer registro de estadísticas
                + def _record_stats(self):
                        recorrer hasta ...
                + self.history["avg"].append(float(np.mean(fitness)))
                + gen = 0
                        recorrer hasta ...
                + parents = self._select_parents(self.tournament_k)
                + def _select_parents(self, tournament_k):
                        recorrer hasta ...
                + return self.tournament_selection(tournament_k, num_select=self.pop_size - self.elite_size)
                + def tournament_selection(self, tournament_k=3, num_select=None):
                        recorrer hasta ...
                + return selected
                + return self.tournament_selection(tournament_k, num_select=self.pop_size - self.elite_size)
                + # 3. Creación de descendencia (cruzamiento)
                + offspring = self._create_offspring(parents)
                + def _create_offspring(self, parents):
                        recorrer hasta ...
                + child_params = blx_alpha_crossover(parent1.params, parent2.params, self.alpha_blx)
                + def blx_alpha_crossover(parent1: np.ndarray, parent2: np.ndarray, blx_alpha=0.3, bounds=None):
                        recorrer hasta ...
                + return child
                + child_params = blx_alpha_crossover(parent1.params, parent2.params, self.alpha_blx)
                        recorrer hasta ...
                + child_params = parent1.params.copy()
                + def copy(self):
                        recorrer hasta ...
                + return individual_copy
                + child = Individual(self.bounds)
                        recorrer hasta ...
                + return offspring
                + self._apply_mutation(offspring)
                + def _apply_mutation(self, offspring):
                        recorrer hasta ...
                + child.params = gaussian_mutation(child.params, self.mutation_rate, self.mutation_scale, self.bounds)
                + def gaussian_mutation(params: np.ndarray, mutation_rate: float, mutation_scale: np.ndarray, bounds=None):
                        recorrer hasta ...
                + return individual_params
                + child.params = gaussian_mutation(child.params, self.mutation_rate, self.mutation_scale, self.bounds)
                + self._evaluate_population(offspring) # Evalúa solo a los nuevos
                        (ya se explicó "_evaluate_population") recorrer hasta ...
                        (ya se explicó "_record_stats()") recorrer hasta ...
                + return final
        run_demo.py
                + # Imprimir resultados
                        recorrer hasta ...
                + print("Tiempo total (s):", results["total_time_s"])

        FIN.